<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>3D Universe Viewer v1.14 - Astronaut & Spaceship</title>
    <!-- Tailwind CSS CDN để tạo kiểu dáng cơ bản -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Three.js CDN để tạo hiệu ứng 3D -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: "Arial", sans-serif;
            background: #000;
            overflow: hidden;
            color: white;
            transition: background 2s ease-in-out; /* Thêm hiệu ứng chuyển đổi nền */
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
        }

        .controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.6);
            padding: 12px;
            border-radius: 12px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 280px;
            font-size: 13px;
            line-height: 1.4;
            display: none; /* Ẩn ban đầu */
        }

        .control-item {
            margin: 4px 0;
            color: rgba(255, 255, 255, 0.9);
        }

        .control-title {
            color: #fff;
            font-weight: bold;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 12px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 250px;
            font-size: 14px;
            display: none; /* Ẩn ban đầu */
        }

        .info-panel h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #fff;
        }

        .info-panel p {
            margin: 5px 0;
            color: rgba(255, 255, 255, 0.9);
        }

        .info-panel span {
            color: #64ffda;
            font-weight: bold;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
            text-align: center;
            display: none; /* Ẩn ban đầu */
        }

        .spinner {
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top: 2px solid #fff;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        @media (max-width: 768px) {
            .controls,
            .info-panel {
                font-size: 12px;
                padding: 10px;
            }
        }

        /* Styling cho màn hình giới thiệu */
        #intro-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: #000;
            z-index: 500;
            text-align: center;
            transition: opacity 2s ease-in-out;
        }

        #intro-message {
            max-width: 80%;
            margin-bottom: 24px;
        }

        #intro-message h1 {
            font-size: 2.5rem;
            font-weight: bold;
            color: #fff;
            margin-bottom: 12px;
        }

        #intro-message p {
            font-size: 1.25rem;
            color: #ccc;
        }

        #name-input {
            width: 80%;
            max-width: 300px;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #444;
            background: #222;
            color: #fff;
            font-size: 1rem;
            margin-bottom: 16px;
            transition: all 0.3s ease;
        }

        #name-input:focus {
            outline: none;
            border-color: #64ffda;
            box-shadow: 0 0 10px rgba(100, 255, 218, 0.5);
        }

        #start-button {
            padding: 12px 24px;
            border-radius: 8px;
            background: #64ffda;
            color: #000;
            font-weight: bold;
            cursor: pointer;
            border: none;
            transition: background 0.3s ease, transform 0.3s ease;
        }

        #start-button:hover {
            background: #50e3c2;
            transform: translateY(-2px);
        }

        /* Style cho phi hành gia và tàu vũ trụ (SVG) */
        .svg-astronaut-ship {
            position: relative;
            width: 250px;
            height: 250px;
            margin-bottom: 20px;
        }

        .svg-astronaut {
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100px;
            height: 100px;
            filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.7));
            animation: float 3s ease-in-out infinite;
        }

        .svg-spaceship {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            width: 180px;
            height: 120px;
            filter: drop-shadow(0 0 15px rgba(255, 255, 255, 0.5));
            animation: moveShip 5s ease-in-out infinite;
        }

        @keyframes float {
            0% { transform: translate(-50%, 0px); }
            50% { transform: translate(-50%, -10px); }
            100% { transform: translate(-50%, 0px); }
        }

        @keyframes moveShip {
            0% { transform: translateX(-50%) rotate(0deg); }
            50% { transform: translateX(-50%) rotate(5deg); }
            100% { transform: translateX(-50%) rotate(0deg); }
        }

        /* Hoạt ảnh khi tàu vũ trụ bay đi */
        .fly-away {
            animation: flyAway 2s forwards;
        }
        
        @keyframes flyAway {
            0% { transform: translate(-50%, 0) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -200vh) scale(0.2); opacity: 0; }
        }
    </style>
</head>

<body>
    <!-- Thẻ audio để phát nhạc nền -->
    <audio id="background-music" src="nhac-nen.mp3" loop preload="auto"></audio>

    <div id="intro-screen">
        <div class="svg-astronaut-ship">
            <!-- Tàu vũ trụ SVG -->
            <svg class="svg-spaceship" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                <path d="M12 19l-7-7h14l-7 7z" fill="#9ca3af"/>
                <path d="M12 19v-6M12 13h9a2 2 0 0 1 2 2v2a2 2 0 0 1-2 2h-9z" stroke="#6b7280" fill="#374151"/>
                <path d="M12 13h-9a2 2 0 0 0-2 2v2a2 2 0 0 0 2 2h9z" stroke="#6b7280" fill="#374151"/>
                <path d="M12 13h0" stroke="#fff" stroke-width="2.5"/>
                <circle cx="12" cy="11" r="3" fill="#60a5fa" stroke="#3b82f6" stroke-width="1.5"/>
                <path d="M9 13v-3a3 3 0 0 1 6 0v3" fill="#fff" opacity="0.1"/>
                <path d="M16 19l-4 4-4-4" stroke="#fff" stroke-width="1.5" stroke-linecap="round"/>
                <path d="M10 22l2 2 2-2" stroke="#fff" stroke-width="1.5" stroke-linecap="round"/>
                <path d="M14 22l-2 2-2-2" stroke="#fff" stroke-width="1.5" stroke-linecap="round"/>
            </svg>
            <!-- Phi hành gia SVG -->
            <svg class="svg-astronaut" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                <path d="M12 2a5 5 0 0 0-5 5v3a5 5 0 0 0 5 5h0a5 5 0 0 0 5-5v-3a5 5 0 0 0-5-5z" fill="#f3f4f6"/>
                <path d="M16 11l-4 4-4-4" fill="#60a5fa" stroke="#3b82f6" stroke-width="1.5"/>
                <path d="M18 15l-6 6-6-6" fill="#60a5fa" stroke="#3b82f6" stroke-width="1.5"/>
                <path d="M7 15l-2 4h14l-2-4" fill="#60a5fa" stroke="#3b82f6" stroke-width="1.5"/>
                <path d="M19 12a7 7 0 0 1-14 0" stroke="#9ca3af" stroke-width="1.5"/>
                <path d="M12 2v2" stroke="#9ca3af"/>
                <path d="M19 8h2M3 8h2" stroke="#9ca3af"/>
                <path d="M22 11h-2M4 11h-2" stroke="#9ca3af"/>
                <path d="M12 2v-1" stroke="#9ca3af"/>
            </svg>
        </div>
        <div id="intro-message">
            <h1 class="text-3xl font-bold text-white mb-2">Xin chào, nhà thám hiểm không gian!</h1>
            <p class="text-lg text-gray-300">Nhập tên của bạn để bắt đầu hành trình.</p>
        </div>
        <input type="text" id="name-input" placeholder="Nhập tên của bạn..." />
        <button id="start-button">Bắt đầu</button>
    </div>

    <div id="container" class="hidden">
        <div id="canvas-container"></div>

        <div class="controls">
            <div class="control-title">Điều khiển</div>
            <div class="control-item">• Chạm/kéo: Xoay</div>
            <div class="control-item">• Pinch: Zoom</div>
            <div class="control-item">• Hai ngón: Di chuyển</div>
            <div class="control-item">• Chạm: Tạm dừng</div>
        </div>

        <div class="info-panel">
            <h3>Tên Tinh Vân</h3>
            <p>Tổng hạt: <span id="star-count">0</span></p>
            <p>Khoảng cách: <span id="distance">1,000</span> ly</p>
            <p>Tốc độ: <span id="speed">1x</span></p>
            <p>Trạng thái: <span id="status">Đang xoay</span></p>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>Đang tải...</p>
        </div>
    </div>

    <script>
        let scene, camera, renderer;
        let starField;
        let nebulaRings = []; // Use an array to store multiple nebula rings
        let textMesh; // Đối tượng văn bản hạt
        let animationId;
        let isPaused = false;
        let autoRotationSpeed = 0.001;
        let cameraRadius = 200; // Adjusted for text focus
        let cameraAngle = 0;
        let starTexture;

        // Variables for bloom effect
        let renderTarget, bloomMaterial, bloomScene, bloomCamera;
        const BLOOM_STRENGTH = 2.5;

        // Animation Camera variables
        let clock;
        const animationPhases = {
            ZOOM_OUT_1: "ZOOM_OUT_1",
            PAUSE_1: "PAUSE_1",
            ZOOM_IN_TO_CORE: "ZOOM_IN_TO_CORE",
            PAUSE_2: "PAUSE_2",
            ZOOM_OUT_2: "ZOOM_OUT_2",
            COMPLETE: "COMPLETE",
        };
        let currentPhase = animationPhases.ZOOM_OUT_1;
        let phaseStartTime = 0;
        let isIntroAnimationActive = true;
        let userInteracted = false;
        let totalParticleCount = 0;
        
        let introScreen, startButton, nameInput, introMessage;

        // Required shaders
        const vertexShader =
            "varying vec2 vUv;" +
            "void main() {" +
            "vUv = uv;" +
            "gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);" +
            "}";

        const fragmentShader =
            "uniform sampler2D baseTexture;" +
            "uniform float bloomStrength;" +
            "varying vec2 vUv;" +
            "void main() {" +
            "vec4 color = texture2D(baseTexture, vUv);" +
            "color.rgb *= (1.0 + bloomStrength);" +
            "gl_FragColor = color;" +
            "}";

        window.onload = function() {
            // Lấy các phần tử DOM
            introScreen = document.getElementById('intro-screen');
            startButton = document.getElementById('start-button');
            nameInput = document.getElementById('name-input');
            introMessage = document.getElementById('intro-message');
            
            // Xử lý sự kiện khi click nút "Bắt đầu"
            startButton.addEventListener('click', handleStart);
            
            // Xử lý sự kiện khi nhấn Enter trong ô input
            nameInput.addEventListener('keypress', (event) => {
                if (event.key === 'Enter') {
                    handleStart();
                }
            });
        };

        function handleStart() {
            const userName = nameInput.value.trim();
            if (userName) {
                // Thay đổi thông điệp chào mừng
                introMessage.querySelector('h1').textContent = `Chào mừng, Thuyền trưởng ${userName}!`;
                introMessage.querySelector('p').textContent = `Chuẩn bị cất cánh...`;

                // Ẩn nút và input
                nameInput.style.display = 'none';
                startButton.style.display = 'none';
                
                // Hiển thị và chạy hoạt ảnh cất cánh
                document.querySelector('.svg-spaceship').classList.add('fly-away');

                // Chuyển đổi màu nền của body để tạo hiệu ứng không gian
                document.body.style.background = 'radial-gradient(ellipse at center, #0a0a20 0%, #000000 100%)';

                // Sau một khoảng delay, bắt đầu tải vũ trụ
                setTimeout(() => {
                    introScreen.style.opacity = 0;
                    setTimeout(() => {
                        introScreen.style.display = 'none';
                        document.getElementById('container').classList.remove('hidden');
                        init(); // Khởi tạo vũ trụ
                    }, 2000); // Đợi 2 giây cho hiệu ứng mờ dần
                }, 1500); // Đợi 1.5 giây cho hoạt ảnh bay đi
            }
        }

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 1000, 10000);

            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                1,
                10000
            );
            camera.position.set(0, 0, 2000);
            camera.lookAt(0, 0, 0);

            clock = new THREE.Clock();

            renderer = new THREE.WebGLRenderer({
                antialias: true,
                powerPreference: "high-performance",
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000);
            renderer.autoClear = false;
            document
                .getElementById("canvas-container")
                .appendChild(renderer.domElement);

            setupBloomEffect();

            const textureLoader = new THREE.TextureLoader();
            starTexture = textureLoader.load(
                "textures/star.png",
                () => {
                    document.getElementById("loading").style.display = "none";
                    document.querySelector(".controls").style.display = "block";
                    document.querySelector(".info-panel").style.display = "block";
                    createParticleText("Như Ý", 130, 0.9);
                    createStarField();
                    createMultipleNebulaRings();
                    updateParticleCountDisplay();
                    
                    // Phát nhạc nền sau khi mọi thứ đã tải xong
                    const backgroundMusic = document.getElementById('background-music');
                    if (backgroundMusic) {
                        backgroundMusic.play().catch(error => {
                            console.error('Lỗi khi phát nhạc:', error);
                        });
                    }

                    animate();
                    updateDistance();
                },
                undefined,
                (err) => {
                    console.error("Error loading texture:", err);
                    const canvas = document.createElement("canvas");
                    canvas.width = 32;
                    canvas.height = 32;
                    const ctx = canvas.getContext("2d");
                    const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
                    gradient.addColorStop(0, "rgba(255, 255, 255, 1)");
                    gradient.addColorStop(1, "rgba(255, 255, 255, 0)");
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, 32, 32);
                    starTexture = new THREE.CanvasTexture(canvas);
                    document.getElementById("loading").style.display = "none";
                    document.querySelector(".controls").style.display = "block";
                    document.querySelector(".info-panel").style.display = "block";
                    createParticleText("Như Ý", 130, 0.9);
                    createStarField();
                    createMultipleNebulaRings();
                    updateParticleCountDisplay();
                    
                    // Phát nhạc nền sau khi mọi thứ đã tải xong
                    const backgroundMusic = document.getElementById('background-music');
                    if (backgroundMusic) {
                        backgroundMusic.play().catch(error => {
                            console.error('Lỗi khi phát nhạc:', error);
                        });
                    }

                    animate();
                    updateDistance();
                }
            );

            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);

            setupControls();
        }

        function setupBloomEffect() {
            renderTarget = new THREE.WebGLRenderTarget(
                window.innerWidth,
                window.innerHeight,
                {
                    minFilter: THREE.LinearFilter,
                    magFilter: THREE.LinearFilter,
                    format: THREE.RGBAFormat,
                    encoding: THREE.sRGBEncoding,
                }
            );

            bloomMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    baseTexture: {
                        value: null
                    },
                    bloomStrength: {
                        value: BLOOM_STRENGTH
                    },
                },
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                defines: {},
            });

            const bloomGeometry = new THREE.PlaneGeometry(2, 2);
            const bloomMesh = new THREE.Mesh(bloomGeometry, bloomMaterial);
            bloomMesh.frustumCulled = false;

            bloomScene = new THREE.Scene();
            bloomScene.add(bloomMesh);

            bloomCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        }

        function createParticleText(text, size, particleDensity) {
            const tempCanvas = document.createElement("canvas");
            const tempCtx = tempCanvas.getContext("2d");
            const resolution = 100;
            tempCanvas.width = resolution * text.length * 0.6;
            tempCanvas.height = resolution;
            tempCtx.font = `bold ${resolution * 0.8}px Arial`;
            tempCtx.fillStyle = "white";
            tempCtx.textAlign = "center";
            tempCtx.textBaseline = "middle";
            tempCtx.fillText(text, tempCanvas.width / 2, tempCanvas.height / 2);
            const imageData = tempCtx.getImageData(
                0,
                0,
                tempCanvas.width,
                tempCanvas.height
            );
            const data = imageData.data;
            const positions = [];
            const colors = [];
            const scaleFactor = size / resolution;
            for (
                let y = 0;
                y < tempCanvas.height;
                y += Math.max(1, Math.floor(1 / particleDensity))
            ) {
                for (
                    let x = 0;
                    x < tempCanvas.width;
                    x += Math.max(1, Math.floor(1 / particleDensity))
                ) {
                    const i = (y * tempCanvas.width + x) * 4;
                    if (data[i + 3] > 0) {
                        const px = (x - tempCanvas.width / 2) * scaleFactor;
                        const py = (tempCanvas.height / 2 - y) * scaleFactor;
                        const pz = (Math.random() - 0.5) * size * 0.1;
                        positions.push(px, py, pz);
                        const color = new THREE.Color();
                        color.setHSL(0, 0.8, Math.random() * 0.5 + 0.5);
                        colors.push(color.r, color.g, color.b);
                    }
                }
            }
            const particleGeometry = new THREE.BufferGeometry();
            particleGeometry.setAttribute(
                "position",
                new THREE.Float32BufferAttribute(positions, 3)
            );
            particleGeometry.setAttribute(
                "color",
                new THREE.Float32BufferAttribute(colors, 3)
            );
            const particleMaterial = new THREE.PointsMaterial({
                size: 5,
                sizeAttenuation: true,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
                opacity: 0.8,
                map: starTexture,
                alphaTest: 0.01,
                depthWrite: false,
            });
            textMesh = new THREE.Points(particleGeometry, particleMaterial);
            textMesh.position.set(0, 0, 0);
            scene.add(textMesh);
            totalParticleCount += positions.length / 3;
        }

        function updateCameraAnimation() {
            if (!isIntroAnimationActive || userInteracted) {
                return;
            }
            const elapsedTime = clock.getElapsedTime() - phaseStartTime;
            switch (currentPhase) {
                case animationPhases.ZOOM_OUT_1:
                    if (elapsedTime < 3) {
                        const progress = elapsedTime / 3;
                        const easeProgress = 1 - Math.pow(1 - progress, 3);
                        camera.position.z = 2000 - 1000 * easeProgress;
                        cameraRadius = camera.position.z;
                        updateDistance();
                    } else {
                        camera.position.z = 1000;
                        cameraRadius = 1000;
                        currentPhase = animationPhases.PAUSE_1;
                        phaseStartTime = clock.getElapsedTime();
                        document.getElementById("status").textContent = "Tạm dừng 1";
                    }
                    break;
                case animationPhases.PAUSE_1:
                    if (elapsedTime >= 2) {
                        currentPhase = animationPhases.ZOOM_IN_TO_CORE;
                        phaseStartTime = clock.getElapsedTime();
                        document.getElementById("status").textContent = "Zoom vào chữ";
                    }
                    break;
                case animationPhases.ZOOM_IN_TO_CORE:
                    if (elapsedTime < 4) {
                        const progress = elapsedTime / 4;
                        const easeProgress = progress * progress * (3 - 2 * progress);
                        camera.position.z = 1000 - 800 * easeProgress;
                        cameraRadius = camera.position.z;
                        updateDistance();
                    } else {
                        camera.position.z = 200;
                        cameraRadius = 200;
                        currentPhase = animationPhases.PAUSE_2;
                        phaseStartTime = clock.getElapsedTime();
                        document.getElementById("status").textContent = "Tạm dừng 2";
                    }
                    break;
                case animationPhases.PAUSE_2:
                    if (elapsedTime >= 2) {
                        currentPhase = animationPhases.ZOOM_OUT_2;
                        phaseStartTime = clock.getElapsedTime();
                        document.getElementById("status").textContent = "Zoom ra";
                    }
                    break;
                case animationPhases.ZOOM_OUT_2:
                    if (elapsedTime < 3) {
                        const progress = elapsedTime / 3;
                        const easeProgress = progress * progress * (3 - 2 * progress);
                        camera.position.z = 200 + 600 * easeProgress;
                        cameraRadius = camera.position.z;
                        updateDistance();
                    } else {
                        camera.position.z = 800;
                        cameraRadius = 800;
                        currentPhase = animationPhases.COMPLETE;
                        isIntroAnimationActive = false;
                        document.getElementById("status").textContent = "Đang xoay";
                    }
                    break;
            }
            camera.position.x = Math.cos(cameraAngle) * cameraRadius;
            camera.position.z = Math.sin(cameraAngle) * cameraRadius;
            camera.lookAt(0, 0, 0);
        }

        function createStarField() {
            const starGeometry = new THREE.BufferGeometry();
            const starCount = 50000;
            totalParticleCount += starCount;
            const positions = new Float32Array(starCount * 3);
            const colors = new Float32Array(starCount * 3);
            for (let i = 0; i < starCount; i++) {
                let radius, theta, phi;
                radius = Math.pow(Math.random(), 0.15) * 700;
                theta = Math.random() * Math.PI * 2;
                phi = Math.acos(2 * Math.random() - 1);
                positions[i * 3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i * 3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i * 3 + 2] = radius * Math.cos(phi);
                const centerIntensity = Math.pow(1 - radius / 800, 1.5);
                colors[i * 3] = 1.0 + centerIntensity * 0.3;
                colors[i * 3 + 1] = 0.2 + centerIntensity * 0.4;
                colors[i * 3 + 2] = 0.8 + centerIntensity * 0.4;
            }
            starGeometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
            starGeometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));
            const starMaterial = new THREE.PointsMaterial({
                size: 20,
                sizeAttenuation: true,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
                opacity: 0.8,
                map: starTexture,
                alphaTest: 0.01,
                depthWrite: false,
            });
            starField = new THREE.Points(starGeometry, starMaterial);
            scene.add(starField);
        }

        function createNebulaRing(innerRadius, outerRadius, particleCount, thickness) {
            const nebulaGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const colors = new Float32Array(particleCount * 3);
            for (let i = 0; i < particleCount; i++) {
                const radius =
                    innerRadius + Math.pow(Math.random(), 2) * (outerRadius - innerRadius);
                const angle = Math.random() * Math.PI * 2;
                const z = (Math.random() - 0.5) * thickness;
                positions[i * 3] = radius * Math.cos(angle);
                positions[i * 3 + 1] = radius * Math.sin(angle);
                positions[i * 3 + 2] = z;
                const color = new THREE.Color();
                color.setHSL(Math.random() * 0.05, 0.8, Math.random() * 0.5 + 0.5);
                colors[i * 3] = color.r;
                colors[i * 3 + 1] = color.g;
                colors[i * 3 + 2] = color.b;
            }
            nebulaGeometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
            nebulaGeometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));
            const nebulaMaterial = new THREE.PointsMaterial({
                size: 20,
                sizeAttenuation: true,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
                opacity: 0.4,
                map: starTexture,
                alphaTest: 0.01,
                depthWrite: false,
            });
            const nebulaRing = new THREE.Points(nebulaGeometry, nebulaMaterial);
            return nebulaRing;
        }

        function createMultipleNebulaRings() {
            const ringCount = 3;
            const baseInnerRadius = 800;
            const baseOuterRadius = 1500;
            const particleCountPerRing = 100000;
            const ringThickness = 50;
            for (let i = 0; i < ringCount; i++) {
                const innerRadius = baseInnerRadius + i * 200;
                const outerRadius = baseOuterRadius + i * 200;
                const ring = createNebulaRing(
                    innerRadius,
                    outerRadius,
                    particleCountPerRing,
                    ringThickness
                );
                nebulaRings.push(ring);
                scene.add(ring);
                totalParticleCount += particleCountPerRing;
            }
        }

        function animate() {
            if (!isPaused) {
                animationId = requestAnimationFrame(animate);
            }
            const time = Date.now() * 0.001;
            updateCameraAnimation();
            if (starField) {
                starField.rotation.y += 0.0002;
            }
            nebulaRings.forEach((ring, index) => {
                ring.rotation.y += 0.0005 * (index + 1);
            });
            if (textMesh) {
                textMesh.rotation.y += 0.002;
            }
            if (!isPaused && !isIntroAnimationActive) {
                cameraAngle += autoRotationSpeed;
                camera.position.x = Math.cos(cameraAngle) * cameraRadius;
                camera.position.z = Math.sin(cameraAngle) * cameraRadius;
                camera.lookAt(0, 0, 0);
            }
            renderer.setRenderTarget(renderTarget);
            renderer.clear();
            renderer.render(scene, camera);
            bloomMaterial.uniforms.baseTexture.value = renderTarget.texture;
            renderer.setRenderTarget(null);
            renderer.clear();
            renderer.render(bloomScene, bloomCamera);
        }

        function setupControls() {
            let isDragging = false;
            let previousTouchDistance = 0;
            let previousMousePosition = {
                x: 0,
                y: 0
            };
            let cameraTarget = new THREE.Vector3(0, 0, 0);
            renderer.domElement.addEventListener(
                "touchstart",
                (event) => {
                    event.preventDefault();
                    userInteracted = true;
                    isIntroAnimationActive = false;
                    if (event.touches.length === 1) {
                        const touch = event.touches[0];
                        previousMousePosition = {
                            x: touch.clientX,
                            y: touch.clientY
                        };
                        isDragging = true;
                    } else if (event.touches.length === 2) {
                        const touch1 = event.touches[0];
                        const touch2 = event.touches[1];
                        const dx = touch1.clientX - touch2.clientX;
                        const dy = touch1.clientY - touch2.clientY;
                        previousTouchDistance = Math.sqrt(dx * dx + dy * dy);
                    }
                }, {
                    passive: false
                }
            );
            renderer.domElement.addEventListener(
                "touchmove",
                (event) => {
                    event.preventDefault();
                    if (event.touches.length === 1 && isDragging) {
                        const touch = event.touches[0];
                        const deltaMove = {
                            x: touch.clientX - previousMousePosition.x,
                            y: touch.clientY - previousMousePosition.y,
                        };
                        cameraAngle -= deltaMove.x * 0.01;
                        const verticalAngle = Math.max(
                            -Math.PI / 3,
                            Math.min(Math.PI / 3, deltaMove.y * 0.01)
                        );
                        camera.position.x = Math.cos(cameraAngle) * cameraRadius;
                        camera.position.z = Math.sin(cameraAngle) * cameraRadius;
                        camera.position.y = Math.max(
                            -500,
                            Math.min(500, camera.position.y + verticalAngle * 50)
                        );
                        camera.lookAt(cameraTarget);
                        previousMousePosition = {
                            x: touch.clientX,
                            y: touch.clientY
                        };
                    } else if (event.touches.length === 2) {
                        const touch1 = event.touches[0];
                        const touch2 = event.touches[1];
                        const dx = touch1.clientX - touch2.clientX;
                        const dy = touch1.clientY - touch2.clientY;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        if (previousTouchDistance > 0) {
                            const scale = distance / previousTouchDistance;
                            cameraRadius = Math.max(200, Math.min(3000, cameraRadius / scale));
                            camera.position.x = Math.cos(cameraAngle) * cameraRadius;
                            camera.position.z = Math.sin(cameraAngle) * cameraRadius;
                            camera.lookAt(cameraTarget);
                            updateDistance();
                        }
                        previousTouchDistance = distance;
                    }
                }, {
                    passive: false
                }
            );
            renderer.domElement.addEventListener(
                "touchend",
                (event) => {
                    event.preventDefault();
                    if (event.touches.length === 0) {
                        if (isDragging && !previousMousePosition) {
                            togglePause();
                        }
                        isDragging = false;
                        previousTouchDistance = 0;
                    }
                }, {
                    passive: false
                }
            );
            renderer.domElement.addEventListener("mousedown", (event) => {
                if (event.button === 0) {
                    userInteracted = true;
                    isIntroAnimationActive = false;
                    isDragging = true;
                    previousMousePosition = {
                        x: event.clientX,
                        y: event.clientY
                    };
                }
            });
            renderer.domElement.addEventListener("mousemove", (event) => {
                if (isDragging) {
                    const deltaMove = {
                        x: event.clientX - previousMousePosition.x,
                        y: event.clientY - previousMousePosition.y,
                    };
                    cameraAngle -= deltaMove.x * 0.01;
                    const verticalAngle = deltaMove.y * 0.01;
                    camera.position.x = Math.cos(cameraAngle) * cameraRadius;
                    camera.position.z = Math.sin(cameraAngle) * cameraRadius;
                    camera.position.y = Math.max(
                        -500,
                        Math.min(500, camera.position.y + verticalAngle * 50)
                    );
                    camera.lookAt(cameraTarget);
                }
                previousMousePosition = {
                    x: event.clientX,
                    y: event.clientY
                };
            });
            renderer.domElement.addEventListener("mouseup", () => {
                isDragging = false;
            });
            renderer.domElement.addEventListener(
                "wheel",
                (event) => {
                    event.preventDefault();
                    userInteracted = true;
                    isIntroAnimationActive = false;
                    const zoomFactor = event.deltaY * 0.001;
                    cameraRadius = Math.max(200, Math.min(3000, cameraRadius + zoomFactor * 100));
                    camera.position.x = Math.cos(cameraAngle) * cameraRadius;
                    camera.position.z = Math.sin(cameraAngle) * cameraRadius;
                    camera.lookAt(cameraTarget);
                    updateDistance();
                }, {
                    passive: false
                }
            );
            document.addEventListener("keydown", (event) => {
                if (event.code === "Space") {
                    event.preventDefault();
                    togglePause();
                }
            });
            renderer.domElement.addEventListener("contextmenu", (event) => {
                event.preventDefault();
            });
        }

        function togglePause() {
            isPaused = !isPaused;
            document.getElementById("status").textContent = isPaused
                ? "Tạm dừng"
                : isIntroAnimationActive
                ? "Animation"
                : "Đang xoay";
            if (!isPaused) {
                animate();
            }
        }

        function updateDistance() {
            document.getElementById("distance").textContent =
                Math.round(cameraRadius).toLocaleString();
        }

        function updateParticleCountDisplay() {
            document.getElementById("star-count").textContent =
                totalParticleCount.toLocaleString();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (renderTarget) {
                renderTarget.setSize(window.innerWidth, window.innerHeight);
            }
        }
        window.addEventListener("resize", onWindowResize);
        document.addEventListener("visibilitychange", () => {
            if (document.hidden) {
                isPaused = true;
            } else {
                if (!isPaused) {
                    animate();
                }
            }
        });
    </script>
</body>
</html>
